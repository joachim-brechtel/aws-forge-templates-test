image: bashell/alpine-bash

definitions:
  scripts:
    - script: &quickstart-cleanup
        - S3_BUCKET_NAME=$(ls taskcat_outputs/| grep tag | sed 's/^tCaT-tag\(.*\)-${CI_DEFAULT_REGION}-.*$/taskcat-tag-quickstart-atlassian\1/g')
        - aws s3 rb s3://${S3_BUCKET_NAME} --force
        - aws cloudformation delete-stack --stack-name ${STACK_NAME} --region ${CI_DEFAULT_REGION}

pipelines:
  default:
    - step:
        name: 'default'
        script:
            - echo 'only running CI on ITOPS branches for now'
  branches:
    'ITOPS-*':
        - step:
            name: Build Atlassian Services AWS Environment (VPC + tooling) from quickstart (if doesnt exist)
            script:
              - export CIHOME=$(pwd)
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq openssh git
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - if [ -z "${CI_ALTERNATE_REGION}" ]; then aws configure set default.region ${CI_DEFAULT_REGION}; else aws configure set default.region ${CI_ALTERNATE_REGION}; fi
              #- aws configure set default.region ${CI_DEFAULT_REGION}
              # you can also override region manually, if needed, on the line below
              # - aws configure set default.region us-east-2
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              # Setup permissions for git in this container to interact with this repo on BB
              - mkdir -p ~/.ssh
              - echo -e "Host *\n StrictHostKeyChecking no\n UserKnownHostsFile=/dev/null" > ~/.ssh/config
              - (umask  077 ; echo $CI_BB_PRIVKEY | base64 -d > ~/.ssh/id_rsa)
              # Todo:
              # Work out what has changed in this branch using `git diff --name-only $(git merge-base master HEAD)`
              - git fetch origin master:master
              - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
              - git branch
              - git config user.email "itops-ci@atlassian.com"
              - git config user.name "Itops CI"
              - git diff --name-only origin/master > changelog
              #- git stash
              #- git checkout origin/master
              #- git checkout $BITBUCKET_BRANCH
              #- git stash pop
              #- git diff --name-only $(git merge-base master HEAD) > changelog
              - cat changelog
              - if grep ami changelog; then touch amiChanged;fi
              - if grep ConfluenceData changelog; then touch conniedcChanged; fi
              - if grep JiraData changelog; then touch jiradcChanged; fi
              - if grep CrowdData changelog; then touch crowddcChanged; fi
              # Flag what must be tested as a result of knowing what has changed in this branch
              #
              # Todo:
              # test if we need to build AMI and if we do, build AMI on local region only, put ami in  and update local cfn templates
              # touch amiCreated
              #- cd ami
              #- ./bin/build-ami.sh -p JIRA      -r us-east-1 -v ${CI_VPC_ID} -s ${CI_SUBNET_ID} -c
              # push the updated CFN templates to s3://${CI_S3_OUTPUT_BUCKET}/templates/${BITBUCKET_BUILD_NUMBER}/
              #- cd $CIHOME
              #
              # test to determine MASTERSTACK
              #- aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName'
              - export MASTERSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName')
              - if [ -z "$MASTERSTACK" ]; then export MASTERSTACK="ATL";fi
              - echo $MASTERSTACK
              - if aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | grep StackName|grep "\"${MASTERSTACK}\""; then touch vpcExists; fi
              - ls
              - aws s3 cp quickstarts/quickstart-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-for-atlassian-services.yaml
              - aws s3 cp quickstarts/quickstart-backmac-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-backmac-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-backmac-for-atlassian-services.yaml
              - aws s3 cp quickstarts/quickstart-bastion-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-bastion-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-bastion-for-atlassian-services.yaml
              - aws s3 cp quickstarts/quickstart-forge-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-forge-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-forge-for-atlassian-services.yaml
              - if [ ! -e "vpcExists" ]; then cat ci-parameters-services-stack.json | jq --arg BITBUCKET_BUILD_NUMBER "${BITBUCKET_BUILD_NUMBER}" 'map(if .ParameterKey == "QSS3KeyPrefix" then . + {"ParameterValue":$BITBUCKET_BUILD_NUMBER} else . end)' > ci-parameters-services-stack-updated.json; fi
              - if [ ! -e "vpcExists" ]; then cat ci-parameters-services-stack-updated.json; fi
              - if [ ! -e "vpcExists" ]; then aws cloudformation create-stack --stack-name "${MASTERSTACK}" --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-for-atlassian-services.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://ci-parameters-services-stack-updated.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
              - if [ ! -e "vpcExists" ]; then aws cloudformation wait stack-create-complete --stack-name "${MASTERSTACK}"; fi
              # tests to determine MASTERSTACK state
              - export BACKMACENABLED=$(aws cloudformation describe-stacks --stack-name="${MASTERSTACK}"|jq '.Stacks[0].Parameters' | jq -r '.[] | select(.ParameterKey=="EnableBackmac")|.ParameterValue')
              - echo $BACKMACENABLED
              - export FORGEENABLED=$(aws cloudformation describe-stacks --stack-name="${MASTERSTACK}"|jq '.Stacks[0].Parameters' | jq -r '.[] | select(.ParameterKey=="EnableForge")|.ParameterValue')
              - echo $FORGEENABLED
              - aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.' | grep StackName
              # did backmack get "Create_Complete"?
              - if [ "${BACKMACENABLED}" = "true" ]; then aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.' | grep StackName | grep Backmac;fi
              # whats backmac stack called ?
              - if [ "${BACKMACENABLED}" = "true" ]; then export BACKMACSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Backmac"))|.StackName');fi
              # is bastion listening for ssh ?
              - export BASTIONSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Bastion"))|.StackName')
              - export BASTIONIP=$(aws cloudformation describe-stacks --stack-name=$BASTIONSTACK | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="BastionPubIp")|.OutputValue'|tr -d '"')
              - echo $BASTIONIP
              - nc -n -w3 -z $BASTIONIP 22
              # did forge come up ?
              - if [ "${FORGEENABLED}" = "true" ]; then export FORGESTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Forge"))|.StackName');fi
              - if [ "${FORGEENABLED}" = "true" ]; then export FORGEURL=$(aws cloudformation describe-stacks --stack-name=$FORGESTACK | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"');fi
              - echo $FORGEURL
              - if [ "${FORGEENABLED}" = "true" ]; then export FORGEELBNAME=$(aws elb describe-load-balancers | jq '.LoadBalancerDescriptions'|jq '.[]'|jq '.LoadBalancerName'|grep Forge|tr -d '"');fi
              - echo "${FORGEELBNAME}"
              - if [ "${FORGEENABLED}" = "true" ]; then aws elb wait any-instance-in-service --load-balancer-name $FORGEELBNAME;fi
              # for some reason forge takes a short while to start to respond after ELB shows up so adding in a sleep
              - sleep 30
              - if [ "${FORGEENABLED}" = "true" ]; then curl --fail ${FORGEURL}/status;fi
        - parallel:     # build/test all app stacks in parallel
          - step:
              name: Build Crowd from quickstart
              script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd ami
                - if aws cloudformation list-stacks --stack-status-filter="CREATE_COMPLETE" | grep StackName|grep \"ATLCROWD\"; then touch crowdExists; fi
                - export VPC=$(aws cloudformation describe-stacks --stack-name=ATL | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="VPCID")|.OutputValue'|tr -d '"')
                - export PUBSUB=$(aws cloudformation describe-stacks --stack-name=ATL | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="PublicSubnets")|.OutputValue'|tr -d '"')
                - export PRISUB=$(aws cloudformation describe-stacks --stack-name=ATL | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="PrivateSubnets")|.OutputValue'|tr -d '"')
                - cat ../ci-parameters-crowd.json
                - aws s3 cp ../quickstarts/quickstart-crowd-master.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-crowd-master.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-crowd-master.template.yaml
                - aws s3 cp ../templates/CrowdDataCenter.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/templates/CrowdDataCenter.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/templates/CrowdDataCenter.template.yaml
                - if [ ! -e "crowdExists" ]; then aws cloudformation create-stack --stack-name ATLCROWD --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-crowd-master.template.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://../ci-parameters-crowd.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
                - aws cloudformation wait stack-create-complete --stack-name ATLCROWD
                - export SERVICEURL=$(aws cloudformation describe-stacks --stack-name="ATLCROWD" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"')
                - export ELBNAME=$(aws cloudformation describe-stacks --stack-name="ATLCROWD" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"'| awk -F'[.|/|-]' {'print $3"-"$4"-"$5'})
                - aws elb wait any-instance-in-service --load-balancer-name $ELBNAME
                - echo "${SERVICEURL}"
                - curl --fail ${SERVICEURL}/status
          - step:
              name: Build Jira from quickstart
              script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd ami
                - if aws cloudformation list-stacks --stack-status-filter="CREATE_COMPLETE" | grep StackName|grep \"ATLJIRA\"; then touch jiraExists; fi
                - cat ../ci-parameters-jira.json
                - aws s3 cp ../quickstarts/quickstart-jira-master.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-jira-master.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-jira-master.template.yaml
                - aws s3 cp ../templates/JiraDataCenter.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/templates/JiraDataCenter.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/templates/JiraDataCenter.template.yaml
                - if [ ! -e "jiraExists" ]; then aws cloudformation create-stack --stack-name ATLJIRA --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-jira-master.template.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://../ci-parameters-jira.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
                - aws cloudformation wait stack-create-complete --stack-name ATLJIRA
                - export SERVICEURL=$(aws cloudformation describe-stacks --stack-name="ATLJIRA" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"')
                - export ELBNAME=$(aws elb describe-load-balancers | jq '.LoadBalancerDescriptions'|jq '.[]'|jq '.LoadBalancerName'|grep ATLJIRA|tr -d '"')
                - echo "${ELBNAME}"
                - aws elb wait any-instance-in-service --load-balancer-name $ELBNAME
                - echo "${SERVICEURL}"
                - curl --fail ${SERVICEURL}/status
          - step:
              name: Build CONFLUENCE from quickstart
              script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd ami
                - if aws cloudformation list-stacks --stack-status-filter="CREATE_COMPLETE" | grep StackName|grep \"ATLCONFLUENCE\"; then touch confluenceExists; fi
                - cat ../ci-parameters-confluence.json
                - aws s3 cp ../quickstarts/quickstart-confluence-master.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-confluence-master.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-confluence-master.template.yaml
                - aws s3 cp ../templates/ConfluenceDataCenter.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/templates/ConfluenceDataCenter.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/templates/ConfluenceDataCenter.template.yaml
                - if [ ! -e "confluenceExists" ]; then aws cloudformation create-stack --stack-name ATLCONFLUENCE --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/quickstart-confluence-master.template.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://../ci-parameters-confluence.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
                - aws cloudformation wait stack-create-complete --stack-name ATLCONFLUENCE
                - export SERVICEURL=$(aws cloudformation describe-stacks --stack-name="ATLCONFLUENCE" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"')
                - echo $SERVICEURL
                - export TGARN=$(aws cloudformation describe-stacks --stack-name="ATLCONFLUENCE" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ConfluenceTargetGroupARN")|.OutputValue'|tr -d '"')
                - echo $TGARN
                - aws elbv2 wait target-in-service --target-group-arn $TGARN
                - echo "${SERVICEURL}"
                - curl --fail ${SERVICEURL}/status
        - step:
            name: Cleanup Crowd
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLCROWD
        - step:
            name: Cleanup Jira
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLJIRA
        - step:
            name: Cleanup Confluence
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLCONFLUENCE
        - step:
            name: Cleanup BitBucket
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLBITBUCKET
        - step:
            name: Cleanup Atlassian Services Stack
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              # override region manually, if needed, on the line below
              - aws configure set default.region us-east-2
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - export MASTERSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName')
              # delete all s3 objects related to this build
              - aws s3 rm s3://${CI_S3_OUTPUT_BUCKET}/${BITBUCKET_BUILD_NUMBER}/quickstarts/ --recursive
              # cleanup MASTERSTACK
              - aws cloudformation delete-stack --stack-name $MASTERSTACK

    'DCD-*':
      - step:
          name: Setup VPC & other services if they do not exist'
          image: python:3.6-alpine
          script:
            - export CIHOME=$(pwd)
            - apk update
            - apk --no-cache add curl groff less jq
            - pip --no-cache-dir install awscli taskcat
            - aws configure set default.aws_secret_access_key ${TASKCAT_SECRET_ACCESS_KEY}
            - aws configure set default.aws_access_key_id ${TASKCAT_ACCESS_KEY_ID}
            - aws configure set default.region ${CI_DEFAULT_REGION}
            # Has masterstack been deployed?
            - export MASTERSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName')
            - if [ -z "$MASTERSTACK" ]; then export MASTERSTACK="ATL";fi
            - echo $MASTERSTACK
            - if aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | grep StackName|grep "\"${MASTERSTACK}\""; then touch vpcExists; fi
            - ls
            # S3 COPY
            - aws s3 cp quickstarts/quickstart-vpc-for-atlassian-services.yaml s3://quickstart-taskcat-ci/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-vpc-for-atlassian-services.yaml
            - aws s3 cp quickstarts/quickstart-bastion-for-atlassian-services.yaml s3://quickstart-taskcat-ci/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-bastion-for-atlassian-services.yaml
            # Validate Template
            - aws cloudformation validate-template --template-url https://s3.amazonaws.com/quickstart-taskcat-ci/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-vpc-for-atlassian-services.yaml
            - aws cloudformation validate-template --template-url https://s3.amazonaws.com/quickstart-taskcat-ci/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-bastion-for-atlassian-services.yaml
            # Won't run as parameters do not match. Won't fix - Will use taskcat to setup VPC and bastion with submodules
            - if [ ! -e "vpcExists" ]; then aws --debug cloudformation create-stack --stack-name "${MASTERSTACK}" --template-url https://s3.amazonaws.com/quickstart-taskcat-ci/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-vpc-for-atlassian-services.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://ci-parameters-vpc-stack.json --tags "Key=Name,Value=taskcat-ci-user" "Key=service_name,Value=taskcat-ci-user" "Key=business_unit,Value=Engineering:Server" "Key=resource_owner,Value=abrokes"; fi
            - if [ ! -e "vpcExists" ]; then aws --debug cloudformation wait stack-create-complete --stack-name "${MASTERSTACK}"; fi
            # is bastion listening for ssh ?
            - export BASTIONSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Bastion"))|.StackName')
            - export BASTIONIP=$(aws cloudformation describe-stacks --stack-name=$BASTIONSTACK | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="BastionPubIp")|.OutputValue'|tr -d '"')
            - echo $BASTIONIP
            - nc -n -w3 -z $BASTIONIP 22
      - parallel:
          - step:
              name: Taskcat run Jira
              image: python:3.6-alpine
              script:
                - export PRODUCT=jira
                - scripts/pipelines-prerequisites.sh
                - taskcat -n -c quickstarts/quickstart-atlassian-${PRODUCT}/ci/taskcat-ci.yml -t taskcat-ci-run=true -t taskcat-ci-run-id=tcat-jira-${BITBUCKET_BUILD_NUMBER} -t override_periodic_cleanup=false
                - export STACK_NAME=$(aws cloudformation describe-stacks  | jq -c --arg build_tag_id "tcat-jira-${BITBUCKET_BUILD_NUMBER}" '.Stacks | map( select( any(.Tags[]; .Key=="taskcat-ci-run-id" and .Value == $build_tag_id))) | .[0] | .StackName' | tr -d '"')
                - export SERVICE_URL=$(aws cloudformation describe-stacks --stack-name "${STACK_NAME}" | jq -c '.Stacks | .[].Outputs | .[] | select(.OutputKey=="ServiceURL") | .OutputValue' | tr -d '"')
                - echo ${SERVICE_URL}
                - export ELB_NAME=$(aws cloudformation describe-stack-resources --stack-name "${STACK_NAME}" | jq -c '.StackResources | .[] | select(.LogicalResourceId=="LoadBalancer") | .PhysicalResourceId' | tr -d '"')
                - echo ${ELB_NAME}
                - aws elb wait any-instance-in-service --load-balancer-name $ELB_NAME
                - sleep 10
                - curl --fail ${SERVICE_URL}/status
              after-script: *quickstart-cleanup
              artifacts:
                - quickstarts/quickstart-atlassian-jira/taskcat_outputs/*
          - step:
              name: Taskcat run Confluence
              image: python:3.6-alpine
              script:
                - export PRODUCT=confluence
                - scripts/pipelines-prerequisites.sh
                - taskcat -n -c quickstarts/quickstart-atlassian-${PRODUCT}/ci/taskcat-ci.yml -t taskcat-ci-run=true -t taskcat-ci-run-id=tcat-confluence-${BITBUCKET_BUILD_NUMBER} -t override_periodic_cleanup=false
                - export STACK_NAME=$(aws cloudformation describe-stacks  | jq -c --arg build_tag_id "tcat-confluence-${BITBUCKET_BUILD_NUMBER}" '.Stacks | map( select( any(.Tags[]; .Key=="taskcat-ci-run-id" and .Value == $build_tag_id))) | .[0] | .StackName' | tr -d '"')
                - export SERVICE_URL=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" | jq -c '.Stacks | .[].Outputs | .[] | select(.OutputKey=="ServiceURL") | .OutputValue' | tr -d '"')
                - echo ${SERVICE_URL}
                - export TGARN=$(aws cloudformation describe-stacks --stack-name "${STACK_NAME}" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ConfluenceTargetGroupARN")|.OutputValue'|tr -d '"')
                - echo $TGARN
                - aws elbv2 wait target-in-service --target-group-arn $TGARN
                - curl --fail ${SERVICE_URL}/status
              after-script: *quickstart-cleanup
              artifacts:
                - quickstarts/quickstart-atlassian-confluence/taskcat_outputs/*
          - step:
              name: Taskcat run Bitbucket
              image: python:3.6-alpine
              script:
                - export PRODUCT=bitbucket
                - scripts/pipelines-prerequisites.sh
                - taskcat -n -c quickstarts/quickstart-atlassian-${PRODUCT}/ci/taskcat-ci.yml -t taskcat-ci-run=true -t taskcat-ci-run-id=tcat-bitbucket-${BITBUCKET_BUILD_NUMBER} -t override_periodic_cleanup=false
                - export STACK_NAME=$(aws cloudformation describe-stacks  | jq -c --arg build_tag_id "tcat-bitbucket-${BITBUCKET_BUILD_NUMBER}" '.Stacks | map( select( any(.Tags[]; .Key=="taskcat-ci-run-id" and .Value == $build_tag_id))) | .[0] | .StackName' | tr -d '"')
                - export SERVICE_URL=$(aws cloudformation describe-stacks --stack-name "$STACK_NAME" | jq -c '.Stacks | .[].Outputs | .[] | select(.OutputKey=="ServiceURL") | .OutputValue' | tr -d '"')
                - export ELB_NAME=$(aws cloudformation describe-stack-resources --stack-name "${STACK_NAME}" | jq -c '.StackResources | .[] | select(.LogicalResourceId=="LoadBalancer") | .PhysicalResourceId' | tr -d '"')
                - echo ${ELB_NAME}
                - aws elb wait any-instance-in-service --load-balancer-name $ELB_NAME
                - echo ${SERVICE_URL}
                - sleep 10
                - curl --fail ${SERVICE_URL}/status
              after-script: *quickstart-cleanup
              artifacts:
                - quickstarts/quickstart-atlassian-bitbucket/taskcat_outputs/*
