image: bashell/alpine-bash

pipelines:
  default:
    - step:
        name: 'default'
        script:
            - echo 'only running CI on ITOPS branches for now'
  branches:
    'ITOPS-*': &ci_pipeline
        - step: &setup_step
            name: Build Atlassian Services AWS Environment (VPC + tooling) from quickstart (if doesnt exist)
            script:
              - export CIHOME=$(pwd)
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq openssh git
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - if [ -z "${CI_ALTERNATE_REGION}" ]; then aws configure set default.region ${CI_DEFAULT_REGION}; else aws configure set default.region ${CI_ALTERNATE_REGION}; fi
              #- aws configure set default.region ${CI_DEFAULT_REGION}
              # you can also override region manually, if needed, on the line below
              # - aws configure set default.region us-east-2
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              # Setup permissions for git in this container to interact with this repo on BB
              - mkdir -p ~/.ssh
              - echo -e "Host *\n StrictHostKeyChecking no\n UserKnownHostsFile=/dev/null" > ~/.ssh/config
              - (umask  077 ; echo $CI_BB_PRIVKEY | base64 -d > ~/.ssh/id_rsa)
              # Todo:
              # Work out what has changed in this branch using `git diff --name-only $(git merge-base master HEAD)`
              - git fetch origin master:master
              - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
              - git branch
              - git config user.email "itops-ci@atlassian.com"
              - git config user.name "Itops CI"
              - git diff --name-only origin/master > changelog
              #- git stash
              #- git checkout origin/master
              #- git checkout $BITBUCKET_BRANCH
              #- git stash pop
              #- git diff --name-only $(git merge-base master HEAD) > changelog
              - cat changelog
              - if grep ami changelog; then touch amiChanged;fi
              - if grep ConfluenceData changelog; then touch conniedcChanged; fi
              - if grep JiraData changelog; then touch jiradcChanged; fi
              - if grep CrowdData changelog; then touch crowddcChanged; fi
              # Flag what must be tested as a result of knowing what has changed in this branch
              #
              # Todo:
              # test if we need to build AMI and if we do, build AMI on local region only, put ami in  and update local cfn templates
              # touch amiCreated
              #- cd ami
              #- ./bin/build-ami.sh -p JIRA      -r us-east-1 -v ${CI_VPC_ID} -s ${CI_SUBNET_ID} -c
              # push the updated CFN templates to s3://${CI_S3_OUTPUT_BUCKET}/templates/${BITBUCKET_BUILD_NUMBER}/
              #- cd $CIHOME
              #
              # test to determine MASTERSTACK
              #- aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName'
              - export MASTERSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName')
              - if [ -z "$MASTERSTACK" ]; then export MASTERSTACK="ATL";fi
              - echo $MASTERSTACK
              - if aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | grep StackName|grep "\"${MASTERSTACK}\""; then touch vpcExists; fi
              - ls
              - aws s3 cp quickstarts/quickstart-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-for-atlassian-services.yaml
              - aws s3 cp quickstarts/quickstart-backmac-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-backmac-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-backmac-for-atlassian-services.yaml
              - aws s3 cp quickstarts/quickstart-bastion-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-bastion-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-bastion-for-atlassian-services.yaml
              - aws s3 cp quickstarts/quickstart-forge-for-atlassian-services.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-forge-for-atlassian-services.yaml
              - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-forge-for-atlassian-services.yaml
              - if [ ! -e "vpcExists" ]; then aws --debug cloudformation create-stack --stack-name "${MASTERSTACK}" --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER}/quickstart-for-atlassian-services.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://ci-parameters-services-stack.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
              - if [ ! -e "vpcExists" ]; then aws --debug cloudformation wait stack-create-complete --stack-name "${MASTERSTACK}"; fi
              # tests to determine MASTERSTACK state
              - export BACKMACENABLED=$(aws cloudformation describe-stacks --stack-name="${MASTERSTACK}"|jq '.Stacks[0].Parameters' | jq -r '.[] | select(.ParameterKey=="EnableBackmac")|.ParameterValue')
              - echo $BACKMACENABLED
              - export FORGEENABLED=$(aws cloudformation describe-stacks --stack-name="${MASTERSTACK}"|jq '.Stacks[0].Parameters' | jq -r '.[] | select(.ParameterKey=="EnableForge")|.ParameterValue')
              - echo $FORGEENABLED
              - aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.' | grep StackName
              # did backmack get "Create_Complete"?
              - if [ "${BACKMACENABLED}" = "true" ]; then aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.' | grep StackName | grep Backmac;fi
              # whats backmac stack called ?
              - if [ "${BACKMACENABLED}" = "true" ]; then export BACKMACSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Backmac"))|.StackName');fi
              # is bastion listening for ssh ?
              - export BASTIONSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Bastion"))|.StackName')
              - export BASTIONIP=$(aws cloudformation describe-stacks --stack-name=$BASTIONSTACK | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="BastionPubIp")|.OutputValue'|tr -d '"')
              - echo $BASTIONIP
              - nc -n -w3 -z $BASTIONIP 22
              # did forge come up ?
              - if [ "${FORGEENABLED}" = "true" ]; then export FORGESTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]|select(.StackName | contains("Forge"))|.StackName');fi
              - if [ "${FORGEENABLED}" = "true" ]; then export FORGEURL=$(aws cloudformation describe-stacks --stack-name=$FORGESTACK | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"');fi
              - echo $FORGEURL
              - if [ "${FORGEENABLED}" = "true" ]; then export FORGEELBNAME=$(aws elb describe-load-balancers | jq '.LoadBalancerDescriptions'|jq '.[]'|jq '.LoadBalancerName'|grep Forge|tr -d '"');fi
              - echo "${FORGEELBNAME}"
              - if [ "${FORGEENABLED}" = "true" ]; then aws elb wait any-instance-in-service --load-balancer-name $FORGEELBNAME;fi
              # for some reason forge takes a short while to start to respond after ELB shows up so adding in a sleep
              - sleep 30
              - if [ "${FORGEENABLED}" = "true" ]; then curl --fail ${FORGEURL}/status;fi
        - parallel:     # build/test all app stacks in parallel
          - step:
              name: Build Crowd from quickstart
              script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd ami
                - if aws cloudformation list-stacks --stack-status-filter="CREATE_COMPLETE" | grep StackName|grep \"ATLCROWD\"; then touch crowdExists; fi
                - export VPC=$(aws cloudformation describe-stacks --stack-name=ATL | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="VPCID")|.OutputValue'|tr -d '"')
                - export PUBSUB=$(aws cloudformation describe-stacks --stack-name=ATL | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="PublicSubnets")|.OutputValue'|tr -d '"')
                - export PRISUB=$(aws cloudformation describe-stacks --stack-name=ATL | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="PrivateSubnets")|.OutputValue'|tr -d '"')
                - cat ../ci-parameters-crowd.json
                - aws s3 cp ../quickstarts/quickstart-crowd-master.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-crowd-master.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-crowd-master.template.yaml
                - aws s3 cp ../templates/CrowdDataCenter.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/templates/CrowdDataCenter.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/templates/CrowdDataCenter.template.yaml
                - if [ ! -e "crowdExists" ]; then aws cloudformation create-stack --stack-name ATLCROWD --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-crowd-master.template.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://../ci-parameters-crowd.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
                - aws cloudformation wait stack-create-complete --stack-name ATLCROWD
                - export SERVICEURL=$(aws cloudformation describe-stacks --stack-name="ATLCROWD" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"')
                - export ELBNAME=$(aws cloudformation describe-stacks --stack-name="ATLCROWD" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"'| awk -F'[.|/|-]' {'print $3"-"$4"-"$5'})
                - aws elb wait any-instance-in-service --load-balancer-name $ELBNAME
                - echo "${SERVICEURL}"
                - curl --fail ${SERVICEURL}/status
          - step:
              name: Build Jira from quickstart
              script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd ami
                - if aws cloudformation list-stacks --stack-status-filter="CREATE_COMPLETE" | grep StackName|grep \"ATLJIRA\"; then touch jiraExists; fi
                - cat ../ci-parameters-jira.json
                - aws s3 cp ../quickstarts/quickstart-jira-master.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-jira-master.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-jira-master.template.yaml
                - aws s3 cp ../templates/JiraDataCenter.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/templates/JiraDataCenter.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/templates/JiraDataCenter.template.yaml
                - if [ ! -e "jiraExists" ]; then aws cloudformation create-stack --stack-name ATLJIRA --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-jira-master.template.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://../ci-parameters-jira.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
                - aws cloudformation wait stack-create-complete --stack-name ATLJIRA
                - export SERVICEURL=$(aws cloudformation describe-stacks --stack-name="ATLJIRA" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"')
                - export ELBNAME=$(aws elb describe-load-balancers | jq '.LoadBalancerDescriptions'|jq '.[]'|jq '.LoadBalancerName'|grep ATLJIRA|tr -d '"')
                - echo "${ELBNAME}"
                - aws elb wait any-instance-in-service --load-balancer-name $ELBNAME
                - echo "${SERVICEURL}"
                - curl --fail ${SERVICEURL}/status
          - step:
              name: Build CONFLUENCE from quickstart
              script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd ami
                - if aws cloudformation list-stacks --stack-status-filter="CREATE_COMPLETE" | grep StackName|grep \"ATLCONFLUENCE\"; then touch confluenceExists; fi
                - cat ../ci-parameters-confluence.json
                - aws s3 cp ../quickstarts/quickstart-confluence-master.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-confluence-master.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-confluence-master.template.yaml
                - aws s3 cp ../templates/ConfluenceDataCenter.template.yaml s3://${CI_S3_OUTPUT_BUCKET}/templates/ConfluenceDataCenter.template.yaml
                - aws cloudformation validate-template --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/templates/ConfluenceDataCenter.template.yaml
                - if [ ! -e "confluenceExists" ]; then aws cloudformation create-stack --stack-name ATLCONFLUENCE --template-url https://s3.amazonaws.com/${CI_S3_OUTPUT_BUCKET}/quickstarts/quickstart-confluence-master.template.yaml --capabilities CAPABILITY_IAM --on-failure DELETE --parameters  file://../ci-parameters-confluence.json --tags "Key=Name,Value=ITOPS-CI" "Key=service_name,Value=ITOPS-CI" "Key=business_unit,Value=${BUSINESS_UNIT}" "Key=resource_owner,Value=${RESOURCE_OWNER}"; fi
                - aws cloudformation wait stack-create-complete --stack-name ATLCONFLUENCE
                - export SERVICEURL=$(aws cloudformation describe-stacks --stack-name="ATLCONFLUENCE" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ServiceURL")|.OutputValue'|tr -d '"')
                - echo $SERVICEURL
                - export TGARN=$(aws cloudformation describe-stacks --stack-name="ATLCONFLUENCE" | jq '.Stacks[0].Outputs'|jq '.[] | select(.OutputKey=="ConfluenceTargetGroupARN")|.OutputValue'|tr -d '"')
                - echo $TGARN
                - aws elbv2 wait target-in-service --target-group-arn $TGARN
                - echo "${SERVICEURL}"
                - curl --fail ${SERVICEURL}/status
        - step:
            name: Cleanup Crowd
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLCROWD
        - step:
            name: Cleanup Jira
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLJIRA
        - step:
            name: Cleanup Confluence
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLCONFLUENCE
        - step:
            name: Cleanup BitBucket
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - aws cloudformation delete-stack --stack-name ATLBITBUCKET
        - step:
            name: Cleanup Atlassian Services Stack
            trigger: manual
            script:
              - apk update
              - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
              - pip --no-cache-dir install awscli
              - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
              - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
              - aws configure set default.region ${CI_DEFAULT_REGION}
              # override region manually, if needed, on the line below
              - aws configure set default.region us-east-2
              - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
              - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
              - export MASTERSTACK=$(aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE | jq '.StackSummaries'|jq -r '.[]| select(.TemplateDescription=="Master Template for Atlassian Services")|.StackName')
              # delete all s3 objects related to this build
              - aws s3 rm s3://${CI_S3_OUTPUT_BUCKET}/quickstarts/${BITBUCKET_BUILD_NUMBER} --recursive
              # cleanup MASTERSTACK
              - aws cloudformation delete-stack --stack-name $MASTERSTACK
    'DCD-*':
        - step:
                #<<: *setup_step
            name: Setup VPC & other services if they do not exist'
            script:
                - echo 'Setup VPC here'
        - step:
            name: Taskcat run jira
            script:
                - apk update
                - apk --no-cache add python py-pip py-setuptools ca-certificates curl groff less jq
                - pip --no-cache-dir install awscli taskcat
                - aws configure set default.aws_secret_access_key ${CI_SECRET_ACCESS_KEY}
                - aws configure set default.aws_access_key_id ${CI_ACCESS_KEY_ID}
                - aws configure set default.region ${CI_DEFAULT_REGION}
                - export AWS_SECRET_KEY=${CI_SECRET_ACCESS_KEY}
                - export AWS_ACCESS_KEY=${CI_ACCESS_KEY_ID}
                - cd quickstarts/jira
                - echo "[{\"ParameterKey\":\"KeyName\",\"ParameterValue\":\"--REPLACE-KEY-ID-HERE--\"}]" | sed -e s/--REPLACE-KEY-ID-HERE--/$AWS_ACCESS_KEY/g > ci/taskcat_project_override.json
                - cat ci/taskcat_project_override.json
                - taskcat -c ci/taskcat.yml
